<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=" 目标 软件破解\n使用 apktool 及 dex2jar 逆向 crackme2.apk ，寻找到爆破点，修改注册逻辑代码，使注册机制失效，使用 apkTool 重新打包生成apk，要求新的apk对任意字符成功注册。（可使用工具： apktool 、 BakSmali 、 dex2jar 、 jd-gui ）。\n"><title>Android crack</title>
<link rel=canonical href=https://cld4h.github.io/blog/zh-cn/p/android-crack/><link rel=stylesheet href=/blog/scss/style.min.0304c6baf04e01a8fe70693791cb744d56a3578a3120a8796cefc66825aa39c7.css><meta property='og:title' content="Android crack"><meta property='og:description' content=" 目标 软件破解\n使用 apktool 及 dex2jar 逆向 crackme2.apk ，寻找到爆破点，修改注册逻辑代码，使注册机制失效，使用 apkTool 重新打包生成apk，要求新的apk对任意字符成功注册。（可使用工具： apktool 、 BakSmali 、 dex2jar 、 jd-gui ）。\n"><meta property='og:url' content='https://cld4h.github.io/blog/zh-cn/p/android-crack/'><meta property='og:site_name' content='cld4h 的博客'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2019-06-18T00:00:00+00:00'><meta property='article:modified_time' content='2019-06-18T00:00:00+00:00'><meta property='og:image' content='https://cld4h.github.io/blog/zh-cn/p/android-crack/smali.png'><meta name=twitter:title content="Android crack"><meta name=twitter:description content=" 目标 软件破解\n使用 apktool 及 dex2jar 逆向 crackme2.apk ，寻找到爆破点，修改注册逻辑代码，使注册机制失效，使用 apkTool 重新打包生成apk，要求新的apk对任意字符成功注册。（可使用工具： apktool 、 BakSmali 、 dex2jar 、 jd-gui ）。\n"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://cld4h.github.io/blog/zh-cn/p/android-crack/smali.png'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/zh-cn/><img src=/blog/img/avataaars_hu_25972a44ed8b91a1.png width=300 height=318 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🏡</span></figure><div class=site-meta><h1 class=site-name><a href=/blog/zh-cn>cld4h 的博客</a></h1><h2 class=site-description>Self sufficient!</h2></div></header><ol class=menu-social><li><a href=mailto:cld4h@disroot.org target=_blank title=email rel=me><svg class="icon icon-tabler icon-tabler-email" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path d="M4 5.5s16 0 16 0c1.19.0 2 .13 2 1.5V17.5C22 18.87 21.19 19 20 19H4C2.81 19 2 18.87 2 17.5V7c0-1.37.81-1.5 2-1.5z"/><path d="M2.5 6c2 2 4 4 5.58 5.25C9.67 12.5 10.83 13 12 13s2.33-.5 3.92-1.75C17.5 10 19.5 8 21.5 6"/><path d="M8.5 12c-2 1.67-4 3.33-6 5"/><path d="M15.5 12c2 1.67 4 3.33 6 5"/></svg></a></li><li><a href=https://github.com/cld4h target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/blog/about/#rss-links target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=/blog/about/#xmpp target=_blank title=xmpp:cld4h@disroot.org rel=me><svg class="icon icon-tabler icon-tabler-messages" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M21 14l-3-3h-7a1 1 0 01-1-1V4a1 1 0 011-1h9a1 1 0 011 1v10"/><path d="M14 15v2a1 1 0 01-1 1H6l-3 3V11a1 1 0 011-1h2"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/blog target=_blank><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/blog/zh-cn/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/blog/zh-cn/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/blog/zh-cn/%E5%85%B3%E4%BA%8E/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li class=menu-bottom-section><ol class=menu><li id=i18n-switch><svg class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 5h7"/><path d="M9 3v2c0 4.418-2.239 8-5 8"/><path d="M5 9c-.003 2.144 2.952 3.908 6.7 4"/><path d="M12 20l4-9 4 9"/><path d="M19.1 18h-6.2"/></svg>
<select name=language title=language onchange="window.location.href=this.selectedOptions[0].value"><option value=https://cld4h.github.io/blog/>English</option><option value=https://cld4h.github.io/blog/zh-tw/>中文正體</option><option value=https://cld4h.github.io/blog/zh-cn/ selected>中文简体</option></select></li><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/blog/zh-cn/p/android-crack/><img src=/blog/zh-cn/p/android-crack/smali_hu_14b1cc499f9fd221.png srcset="/blog/zh-cn/p/android-crack/smali_hu_14b1cc499f9fd221.png 800w, /blog/zh-cn/p/android-crack/smali_hu_6a8ed6227b4f859.png 1600w" width=800 height=436 loading=lazy alt="Featured image of post Android crack"></a></div><div class=article-details><div class=article-title-wrapper><h2 class=article-title><a href=/blog/zh-cn/p/android-crack/>Android crack</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 18, 2019</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 13 分钟</time></div></footer></div></header><section class=article-content><div class=sect1><h2 id=_目标>目标</h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p>软件破解</p></li></ol></div><div class=paragraph><p>使用 <code>apktool</code> 及 <code>dex2jar</code> 逆向 <code>crackme2.apk</code> ，寻找到爆破点，修改注册逻辑代码，使注册机制失效，使用 <code>apkTool</code> 重新打包生成apk，要求新的apk对任意字符成功注册。（可使用工具： <code>apktool</code> 、 <code>BakSmali</code> 、 <code>dex2jar</code> 、 <code>jd-gui</code> ）。</p></div><div class="olist arabic"><ol class=arabic start=2><li><p>注册机开发</p></li></ol></div><div class=paragraph><p>逆向示例程序 <code>crackme.apk</code> ，根据 <code>dex2jar</code> 和 <code>JD-GUI</code> 工具，查看java源码，分析注册机制，写出注册机程序。</p></div></div></div><div class=sect1><h2 id=_环境说明>环境说明</h2><div class=sectionbody><table class="tableblock frame-all grid-all stretch"><col style=width:50%><col style=width:50%><tbody><tr><td class="tableblock halign-left valign-top"><p class=tableblock>工具</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>版本</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>apktool</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>v2.4.0 with smali v2.2.6 and baksmali v2.2.6</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>OpenJDK</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.8.0_212</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>dex2jar</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>2.0</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>jd-gui</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>1.5.2</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>Android Studio</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Android Studio 3.4.1</p><p class=tableblock>Build #AI-183.6156.11.34.5522156, built on May 2, 2019</p><p class=tableblock>JRE: 1.8.0_152-release-1343-b16-5323222 amd64</p><p class=tableblock>JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o</p><p class=tableblock>Linux 5.1.8-arch1-1-ARCH</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>AVD 虚拟机</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Nexus 5X API 28 x86</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class=tableblock>ADB</p></td><td class="tableblock halign-left valign-top"><p class=tableblock>Android Debug Bridge version 1.0.41
Version 28.0.3-5475833</p></td></tr></tbody></table></div></div><div class=sect1><h2 id=_软件破解>软件破解</h2><div class=sectionbody><div class=sect2><h3 id=_反编译过程说明>反编译过程说明</h3><div class=paragraph><p>使用 <code>apktool</code> 进行反编译，执行：</p></div><div class=literalblock><div class=content><pre>apktool d crackme2.apk</pre></div></div><div class=paragraph><p>得到 <code>crackme2</code> 目录，查看其中文件及目录结构：</p></div><div class=literalblock><div class=content><pre>cd crackme2
tree . &gt; t.txt</pre></div></div><div class=paragraph><p>输出的 <code>t.txt</code> 中内容如下：</p></div><div class=listingblock><div class=title>t.txt</div><div class=content><pre>.
├── AndroidManifest.xml
├── apktool.yml
├── original
│   ├── AndroidManifest.xml
│   └── META-INF
│       ├── CERT.RSA
│       ├── CERT.SF
│       └── MANIFEST.MF
├── res
│   ├── drawable-hdpi-v4
│   │   └── icon.png
│   ├── drawable-ldpi-v4
│   │   └── icon.png
│   ├── drawable-mdpi-v4
│   │   └── icon.png
│   ├── layout
│   │   └── main.xml
│   └── values
│       ├── ids.xml
│       ├── public.xml
│       └── strings.xml
├── smali
│   └── com
│       └── lohan
│           └── crackme0a
│               ├── Main.smali
│               ├── R$attr.smali
│               ├── R$drawable.smali
│               ├── R$id.smali
│               ├── R$layout.smali
│               ├── R$string.smali
│               └── R.smali
└── t.txt

12 directories, 21 files</pre></div></div><div class=paragraph><p>当使用 <code>apktool</code> 工具反编译 apk 文件后，会在反编译工程目录下生成一个 <code>smali</code> 目录，其中保存了所有反编译出的 <code>smali</code> 文件，这些文件的功能是根据程序包的层次结构生成相应的目录。在 Android 应用程序中，在程序编译前的所有 Java 类都会在编译后的相应目录下生成独立的 <code>smali</code> 文件，无论是普通类、抽象类、接口类或者内部类，在反编译后的代码中都以独立的 <code>.smali</code> 格式文件存放。每个 <code>.smali</code> 格式文件都由若干代码语句组成，所有的代码语句都遵循了严格的语法规范。</p></div></div><div class=sect2><h3 id=_smali文件格式信息说明>smali文件格式信息说明</h3><div class=paragraph><p>通常来说， <code>.smali</code> 格式文件的前3行代码描述了当前类的一些信息，具体格式如下所示：</p></div><div class=literalblock><div class=content><pre>.class &lt;访问权限&gt; [修饰关键字] &lt;类名&gt;
.super &lt;父类名&gt;
.source &lt;源文件名&gt;</pre></div></div><div class=paragraph><p>例如在 <code>Main.smali</code> 文件中，前三行为</p></div><div class=literalblock><div class=content><pre>.class public Lcom/lohan/crackme0a/Main;
.super Landroid/app/Activity;
.source &#34;Main.java&#34;</pre></div></div><div class=paragraph><p>第一行代码中的 <code>.class</code> 指令指定了当前类的类名。类名开头的字符“L”遵循了 Dalvik VM 字节码的约定规则，表示后面跟随的字符串为一个类</p></div><div class=paragraph><p>第二行代码中的 <code>.super</code> 指令设置了当前的父类，本实例 <code>Lcom/lohan/crackme0a/Main</code> 的父类是 <code>Landroid/app/Activity</code></p></div><div class=paragraph><p>第三行代码中的 <code>.source</code> 指令设置了当前类的源文件名。</p></div><div class=paragraph><p>前三行代码后的代码部分就是整个类的主题部分，一个Android程序类可以由多个字段或方法组成。在 <code>smali</code> 文件中，使用 <code>.field</code> 指令来声明字段。这里字段有静态字段和实例字段两种。具体说明如下所示。</p></div><div class=paragraph><p>静态字段的声明格式如下：</p></div><div class=literalblock><div class=content><pre># static fields
.field &lt;访问权限&gt; static [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;</pre></div></div><div class=paragraph><p>当 <code>baksmali</code> 生成 <code>smali</code> 文件时，会在静态字段声明的起始处添加 <code>static fields</code> 注释。我们可以发现，在 <code>smali</code> 文件中的注释与 Dalvik VM 中的语法一样，都是以“#”开头。在 <code>.field</code> 指令后会紧跟着“访问权限”指令，这里的访问权限可以是 <code>public</code> 、 <code>private</code> 、 <code>protected</code> 。“修饰关键字”描述了字段的其他属性，例如 <code>synthetic</code> 。指令的最后是 “字段名”和“字段类型”，使用冒号进行分隔，语法与 Dalvik VM 一样。</p></div><div class=paragraph><p>实例字段的声明与静态字段类似，只是少了 <code>static</code> 关键字， 其具体格式如下：</p></div><div class=literalblock><div class=content><pre># instance fields
.field &lt;访问权限&gt; [修饰关键字] &lt;字段名&gt;:&lt;字段类型&gt;</pre></div></div><div class=paragraph><p>直接方法的声明格式如下所示：</p></div><div class=literalblock><div class=content><pre># direct methods
.method &lt;访问权限&gt; [修饰关键字] &lt;方法原型&gt;
  &lt;.locals&gt;
[.parameter]
[.prologue]
[.line]
&lt;代码体&gt;
.end method</pre></div></div><div class="olist arabic"><ol class=arabic><li><p><code>direct methods</code> 是 <code>baksmali</code> 添加的注释，访问权限和修饰关键字与字段的描述相同，方法原型描述了方法的名称、参数与返回值</p></li><li><p><code>.locals</code> 指定了使用的局部变量的个数。</p></li><li><p><code>.parameter</code> 指定了方法的参数，与Dalvik VM语法中使用的 <code>.parameters</code> 指定的参数个数不同，每个 <code>.parameter</code> 指令表明使用一个参数，假如在方法中使用了3个参数，那么就会出现3条 <code>.parameter</code> 指令。</p></li><li><p><code>.prologue</code> 指定了代码的开始处，混淆过的代码可能去除了该指令。</p></li><li><p><code>.line</code> 指定了该处指令在源代码中的行号，同理，混淆过的代码可能去除了行号信息。</p></li></ol></div><div class=paragraph><p>声明虚方法的格式与声明直接方法的相同，只是起始处的注释为 <code>virtual methods</code> 而已。如果某一个类实现了接口，则会在 <code>smali</code> 文件中使用 <code>.implements</code> 指令来声明，具体声明格式如下所示</p></div><div class=literalblock><div class=content><pre># interfaces
. implements &lt;接口名&gt;</pre></div></div><div class=paragraph><p><code>.implements</code> 是接口关键字，其后的接口名是 <code>DexClassDef</code> 结构中 <code>interfacesOff</code> 字段指定的内容。
当一个类使用了注解时，会在 <code>smali</code> 文件中使用 <code>.annotation</code> 指令进行声明，声明注解的语法格式如下所示：</p></div><div class=literalblock><div class=content><pre># annotations
.annotation [注解属性] &lt;注解类名&gt;
	[注解字段 = 值]
.end annotation</pre></div></div><div class=paragraph><p>在 Android 程序中，注解的作用范围可以是类、方法或字段。如果注解作用范围是类，则 <code>.annotation</code> 指令会直接在 <code>smali</code> 文件中定义。如果是方法或字段，则会在方法或字段定义中包含 <code>.annotation</code> 指令。</p></div><div class="admonitionblock tip"><div class=table-wrapper><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>更多 <code>smali</code> 相关知识，可参阅 Gabor Paller 所写的《Dalvik opcodes》一文。 <a href=http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html>链接</a></td></tr></tbody></table></div></div></div><div class=sect2><h3 id=_修改破解过程说明>修改破解过程说明</h3><div class=paragraph><p>回到我们的 <code>crackme2.apk</code> 实例，直接分析 <code>smali</code> 指令不太方便，我们先通过 <code>dex2jar</code> 工具反编译出源码，方便理解程序运行的逻辑。</p></div><div class=paragraph><p>先解压apk</p></div><div class=literalblock><div class=content><pre>unzip crackme2.apk</pre></div></div><div class=paragraph><p>在解压出的文件中找到 <code>classes.dex</code> 文件，进行反编译。</p></div><div class=literalblock><div class=content><pre>d2j-dex2jar.sh classes.dex</pre></div></div><div class=paragraph><p>生成 <code>classes-dex2jar.jar</code> 文件，用 <code>jd-gui</code> 工具打开后可以看到 <code>com.lohan.crackme0a</code> 包。打开 <code>Main.class</code> ，可看到其中的 <code>onClick()</code> 函数</p></div><div class=imageblock><div class=content><img src=./src.png alt=onClick函数></div><div class=title>Figure 1. onClick()函数</div></div><div class=paragraph><p>破解的方法一目了然：只要我们不让程序进入到图中 <code>if</code> 分支内部即可。</p></div><div class=paragraph><p>破解的关键在于 <code>if-nez</code> 指令。</p></div><div class=paragraph><p>打开 <code>smali/com/lohan/crackme0a/Main.smali</code> 文件，搜索 <code>if-nez</code> 指令</p></div><div class=imageblock><div class=content><img src=./smali.png alt=Main.smali代码></div><div class=title>Figure 2. Main.smali 代码</div></div><div class=paragraph><p>将光标选中高亮的代码行改成 <code>goto :cond_0</code> ，这样整个破解代码工作就完成了。</p></div><div class=paragraph><p>当修改完 <code>smali</code> 文件的代码后，接下来就可以将修改后的文件重新编译并打包成apk文件。编译apk文件的命令格式为：</p></div><div class=literalblock><div class=content><pre>apktool b[uild] [options] [&lt;app_path&gt;] -o [&lt;out_file&gt;]</pre></div></div><div class=paragraph><p>执行：</p></div><div class=literalblock><div class=content><pre>apktool b crackme2/ -o crackme2-unsigned.apk</pre></div></div><div class=paragraph><p>因为现在编译生成的 <code>crackme2-unsigned.apk</code> 格式还没有签名，所以不能进行安装并测试，接下来需要对 apk 文件进行签名。</p></div><div class=paragraph><p>签名的方法有很多种。</p></div><div class=paragraph><p>可以通过 <code>signapk.jar</code> 进行签名。 <code>signapk.jar</code> 工具是Android源码目录下的 <code>build/tools/signapk/Signapk.java</code> 文件中实现的，源码编译后可以在 <code>out/host/linux-x86/framework</code> 目录中找到。使用 <code>signapk.jar</code> 签名时需要提供签名文件，可以使用 Android 源码中提供的签名文件 <code>testkey .pk8</code> 和 <code>testkey.x509.pem</code> 这两个文件位于Android源码的 <code>build/target/product/security</code> 目录中。</p></div><div class=paragraph><p>也可以通过 <code>jarsigner</code> 进行签名。
可以使用 <code>keytool</code> 生成自签名证书，命令如下：</p></div><div class=literalblock><div class=content><pre>keytool -genkey -alias android.keystore -keyalg RSA -validity 20000 -keystore android.keystore</pre></div></div><div class=paragraph><p>然后使用 <code>jarsigner</code> 对 apk 进行签名，命令</p></div><div class=literalblock><div class=content><pre>jarsigner -verbose -keystore android.keystore -signedjar crackme2-selfsigned.apk crackme2-unsigned.apk android.keystore</pre></div></div><div class=paragraph><p>打开 Android Studio 中的AVD Manager， 启动Android虚拟机。
通过 <code>adb devices</code> 确认设备可用，通过 <code>adb install crackme2-selfsigned.apk</code> 安装</p></div><div class=paragraph><p>打开app，验证破解成功。</p></div><div class="imageblock text-center"><div class=content><img src=./yz-1.png alt=输入任意字符串></div><div class=title>Figure 3. 输入任意字符串</div></div><div class="imageblock text-center"><div class=content><img src=./yz-2.png alt=验证成功></div><div class=title>Figure 4. 验证成功</div></div></div></div></div><div class=sect1><h2 id=_注册机开发>注册机开发</h2><div class=sectionbody><div class=sect2><h3 id=_软件破解_2>软件破解</h3><div class=paragraph><p>类似之前的步骤，通过 <code>unzip</code> 得到 dex 文件后通过 <code>dex2jar</code> 工具得到 jar 包，在 <code>jd-gui</code> 中查看反编译得到的源码。</p></div><div class=paragraph><p>通过搜索特定的字符串找到关键函数。比如，我通过搜索 <code>Registerd successfully\nPlease write Tutorial How Found key?!</code> 字符串找到了函数 <code>_check_code()</code> ，只有当 <code>_check_code()</code> 返回真时才会有注册成功的消息提示。</p></div><div class=paragraph><p>通过 <code>apktool</code> 工具将 <code>crackme.apk</code> 反编译，打开 <code>crackme/smali/Com/zAWS/KeygenMe/main.smali</code> ，搜索 <code>_check_code()</code> ，（1680行）。</p></div><div class=paragraph><p>通过分析源码可以发现， <code>_check_code</code> 函数中有4处返回 <code>false</code> 最后一处返回 <code>true</code></p></div><div class=imageblock><div class=content><img src=./checkcode.png alt=_check_code()函数></div></div><div class=paragraph><p>对应 <code>main.smali</code> 文件中第1809、1828、1857、1870行的 <code>goto: goto_0</code> 指令。</p></div><div class=imageblock><div class=content><img src=./goto-1.png alt=goto-1></div></div><div class=imageblock><div class=content><img src=./goto-2.png alt=goto-2></div></div><div class=imageblock><div class=content><img src=./goto-3.png alt=goto-3></div></div><div class=imageblock><div class=content><img src=./goto-4.png alt=goto-4></div></div><div class=paragraph><p>前三个在执行 <code>goto :goto_0</code> 之前均执行 <code>move v0, v5</code> ，把 <code>v5</code> 中的内容复制到 <code>v0</code> ；而最后一个在执行 <code>goto :goto_0</code> 之前执行的是 <code>move v0, v6</code> ，把 <code>v6</code> 中的内容复制到了 <code>v0</code></p></div><div class=paragraph><p><code>goto_0</code> 处的指令仅仅是返回 <code>v0</code> 中的值。如图：</p></div><div class=imageblock><div class=content><img src=./goto0.png alt=goto0></div></div><div class=paragraph><p>所以我判断前三个 <code>goto</code> 指令对应于 <code>return false</code> ，最后的 <code>goto</code> 指令对应于 <code>return true</code></p></div><div class=paragraph><p>查看 <code>v5</code> 和 <code>v6</code> 中的内容：</p></div><div class=imageblock><div class=content><img src=./v5v6.png alt=v5v6></div></div><div class=paragraph><p>根据上面的分析，我们有充分的理由认为将 <code>v5</code> 中的内容改为 <code>0x1</code> 后， <code>_check_code</code> 函数将永远返回 <code>true</code> ，进而达到注册成功的效果。</p></div><div class=paragraph><p>通前面一样，作了更改后通过</p></div><div class=literalblock><div class=content><pre>apktool b crackme/ -o crackme-unsigned.apk</pre></div></div><div class=paragraph><p>重新编译，再通过</p></div><div class=literalblock><div class=content><pre>jarsigner -verbose -keystore android.keystore -signedjar crackme-selfsigned.apk crackme-unsigned.apk android.keystore</pre></div></div><div class=paragraph><p>进行自签名。通过</p></div><div class=literalblock><div class=content><pre>adb install crackme-selfsigned.apk</pre></div></div><div class=paragraph><p>安装后运行验证</p></div><div class="imageblock text-center"><div class=content><img src=./crackme-selfsigned.png alt=破解成功></div><div class=title>Figure 5. 破解成功</div></div></div><div class=sect2><h3 id=_注册机开发_2>注册机开发</h3><div class=paragraph><p>注册机开发实质上就是将前面提到的 <code>_check_code()</code> 函数的机理分析清楚。</p></div><div class=paragraph><p>错误的注册码会进入使程序在 <code>_check_code()</code> 时进入前4个 <code>if</code> 语句，折戟沉沙；我们要想办法是程序跳过前四个 <code>if</code> 语句。</p></div><div class=paragraph><p>下面我将从头至尾详细分析代码内容，分析的过程也是我思考和实验的过程。</p></div><div class=sect3><h4 id=_readfile_函数><code>_readfile()</code> 函数</h4><div class=paragraph><p>单看可能一头雾水，但联系后面的 <code>_decrypt()</code> 函数——由于 <code>_readfile()</code> 的结果传给了 <code>_decrypt()</code> 进行解密，我们猜其中应该是密文。</p></div><div class=listingblock><div class=title>main.java</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _readfile() throws Exception {
	File file = Common.File;
	String str = (file = Common.File).getDirInternal();
	main main1 = mostCurrent;
	if (File.Exists(str, _file_name)) {// <b class=conum>(1)</b>
		File.TextReaderWrapper textReaderWrapper = new File.TextReaderWrapper();
		File file1 = Common.File;
		String str1 = (file1 = Common.File).getDirInternal();
		main main2 = mostCurrent;
		textReaderWrapper.Initialize((InputStream)File.OpenInput(str1, _file_name).getObject());// <b class=conum>(2)</b>
		str1 = textReaderWrapper.ReadLine();
		textReaderWrapper.Close();
		return str1;// <b class=conum>(3)</b>
	}
    return &#34;&#34;;
}</code></pre></div></div><div class="colist arabic"><ol><li><p>读取 <code>_file_name</code> 文件</p></li><li><p>打开 <code>_file_name</code> 文件</p></li><li><p>以字符串的形式返回文件内容。</p></li></ol></div><div class=paragraph><p>我们搜索 <code>_file_name</code> ，发现其被赋值为 <code>key.txt</code> ，后续步骤中我们会通过 <code>adb shell</code> 来查看其中的内容。</p></div></div><div class=sect3><h4 id=_decrypt_函数和_encrypt_函数><code>_decrypt()</code> 函数和 <code>_encrypt()</code> 函数</h4><div class=paragraph><p><code>_decrypt()</code> 函数，顾名思义是进行解密操作，解密的前提是加密，所以我们这里把加解密对照着看。由于反编译出的代码依赖于 <code>B2A</code> 库，这里我放入我修改后的代码。</p></div><div class=paragraph><p>先看加密函数：</p></div><div class=listingblock><div class=title>main.java</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _encrypt(String paramString1, String paramString2) throws Exception{
        byte[] arrayOfByte2 = _bconv.HexToBytes(_made_key());
        byte[] arrayOfByte1 = _bconv.StringToBytes(paramString1 + &#34;zAWS!&#34;, &#34;UTF8&#34;);
        CipherWrapper.KeyGeneratorWrapper keyGeneratorWrapper = new CipherWrapper.KeyGeneratorWrapper();
        CipherWrapper cipherWrapper = new CipherWrapper();
        cipherWrapper.Initialize(&#34;DES/ECB/NoPadding&#34;);
        keyGeneratorWrapper.Initialize(&#34;DES&#34;);
        keyGeneratorWrapper.KeyFromBytes(arrayOfByte2);
        arrayOfByte1 = cipherWrapper.Encrypt(arrayOfByte1, keyGeneratorWrapper.getKey(), false);
        return bytesToHex(arrayOfByte1);// <b class=conum>(1)</b>
}</code></pre></div></div><div class="colist arabic"><ol><li><p>与反编译的代码不同，原始程序中此处是将解密结果写入 <code>key.txt</code> 文件，返回空串；在我的注册机中就没必要这么做了。</p></li></ol></div><div class=paragraph><p>浏览代码可知加密操作使用了ECB模式的DES加密方案，这个方案的实现是需要第三方库的。</p></div><div class=paragraph><p>在 <code>anywheresoftware.b4a.agraham.encryption</code> 包中可以找到其中 <code>CipherWrapper</code> 类的实现。</p></div><div class=paragraph><p>简便起见，我们可以将这个类整个复制一份到我们的注册机项目中。具体过程很简单，注意修改包名及删除annotation即可。此处不再展示修改过后的内容。</p></div><div class=paragraph><p>下面来看 <code>_decrypt()</code> 函数</p></div><div class=listingblock><div class=title>main.java</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _decrypt(String paramString) throws Exception {
        byte[] arrayOfByte2 = HexToBytes(_made_key());
        byte[] arrayOfByte1 = HexToBytes(paramString);
        CipherWrapper.KeyGeneratorWrapper keyGeneratorWrapper = new CipherWrapper.KeyGeneratorWrapper();
        CipherWrapper cipherWrapper = new CipherWrapper();
        cipherWrapper.Initialize(&#34;DES/ECB/NoPadding&#34;);
        keyGeneratorWrapper.Initialize(&#34;DES&#34;);
        keyGeneratorWrapper.KeyFromBytes(arrayOfByte2);
        arrayOfByte1 = cipherWrapper.Decrypt(arrayOfByte1, keyGeneratorWrapper.getKey(), false);
        return _bconv.StringFromBytes(arrayOfByte1, &#34;UTF8&#34;).substring(0, 11);// <b class=conum>(1)</b>
}</code></pre></div></div><div class="colist arabic"><ol><li><p>返回值是长度为11的字符串</p></li></ol></div><div class="admonitionblock tip"><div class=table-wrapper><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>正确解密后的结果应该是我们输入 <code>Activate</code> 对话框的11位数（再经过一个简单重排列）</td></tr></tbody></table></div></div><div class=paragraph><p>比较加密，解密过程，发现两者均需要调用 <code>_made_key()</code> 函数，因而我们需要分析 <code>_made_key()</code> 函数</p></div></div><div class=sect3><h4 id=_made_key_函数><code>_made_key()</code> 函数</h4><div class=listingblock><div class=title>反编译结果</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _made_key() throws Exception {
    main main1 = mostCurrent;
    String str1 = _imei.substring(0, 2);
    main main2 = mostCurrent;
    String str2 = _imei;
    main main3 = mostCurrent;
    int i = _imei.length();
    main3 = mostCurrent;
    str2 = str2.substring(i - 2, _imei.length());
    StringBuilder stringBuilder = (new StringBuilder()).append(str1);
    main3 = mostCurrent;
    return stringBuilder.append(_mac_address).append(str2).toString();
  }</code></pre></div></div><div class=listingblock><div class=title>修改后的代码</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _made_key() {
        String str1 = IMEI_String.substring(0, 2);
        String str2 = IMEI_String;
        int i = IMEI_String.length();
        str2 = str2.substring(i - 2, IMEI_String.length());
        StringBuilder stringBuilder = (new StringBuilder()).append(str1);
        return stringBuilder.append(MAC_String).append(str2).toString();
}</code></pre></div></div><div class=paragraph><p>讲到这里，需要介绍一下我引入的两个全局变量：</p></div><div class=listingblock><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String IMEI_String;
public static String MAC_String;</code></pre></div></div><div class=paragraph><p>顾名思义是IMEI标识和MAC地址，均为 <code>String</code> 类型。两个重要参数的取值过程在下面会详细介绍。
除此之外，我还删去了莫名其妙的 <code>mostCurrent</code> 赋值语句。</p></div><div class=paragraph><p>分析和修改至此，我们需要暂且放慢脚步，验证一下我们所做的推断和所修改的代码都是正确的。下面我将以验证 <code>_made_key()</code> 函数的正确性为例，介绍我所用的调试方法。</p></div></div><div class=sect3><h4 id=_验证工作打印字符串>验证工作：打印字符串</h4><div class=paragraph><p>前文提到， <code>_encrypt()</code> 函数将计算结果写入了 <code>key.txt</code> 文件。回想到老师上课所讲，Android 应用安装后资源文件、运行时所需的 lib库、启动加载的配置文件的存放路径是 <code>/data/data/&lt;包名></code> 我们不禁思索：能不能通过 <code>adb shell</code> 查看 <code>key.txt</code> 中的内容呢？</p></div><div class=paragraph><p>打开 Android Studio 的 AVD Manager，启动虚拟机。</p></div><div class=paragraph><p>在终端输入</p></div><div class=literalblock><div class=content><pre>adb root</pre></div></div><div class=paragraph><p>以root权限启动adb shell，输入</p></div><div class=literalblock><div class=content><pre>adb shell</pre></div></div><div class=paragraph><p>进入模拟器手机终端。</p></div><div class=paragraph><p>切换目录到 <code>/data/data/Com.zAWS.KeygenMe</code></p></div><div class=paragraph><p><code>ls</code> 列出目录名发现有 <code>files</code> 文件夹</p></div><div class=paragraph><p>进入后看到 <code>key.txt</code> ，通过</p></div><div class=literalblock><div class=content><pre>cat key.txt</pre></div></div><div class=paragraph><p>查看其中内容。</p></div><div class="imageblock text-center"><div class=content><img src=./key.png alt=key.txt文件></div><div class=title>Figure 6. 查看key.txt文件(图是后截的，图中的内容其实就是我这台手机成功注册的key)</div></div><div class="admonitionblock tip"><div class=table-wrapper><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>能不能利用同样的机制打印出我们想查看的字符串呢？</td></tr></tbody></table></div></div><div class=paragraph><p>查看 <code>main.smali</code> 文件，找到 <code>_encrypt()</code> 函数，其中调用 <code>_write2file()</code> 函数的语句如下：</p></div><div class=literalblock><div class=content><pre>invoke-static {v0}, LCom/zAWS/KeygenMe/main;-&gt;_write2file(Ljava/lang/String;)Ljava/lang/String;</pre></div></div><div class=paragraph><p>该函数只接收一个参数（上面的 <code>v0</code> ），该参数指定要打印的字符串。</p></div><div class=paragraph><p>然而，如果我们仅仅利用上面一条语句是不够的。因为 <code>_write2file()</code> 函数默认写入 <code>_file_name</code> 文件。而 <code>_file_name</code> 的值一直是 <code>key.txt</code> 。</p></div><div class=paragraph><p>因此我们需要更改 <code>_file_name</code> 的值。具体方法也是找到 <code>main.smali</code> 中的对应的语句分析其各参数和条用过程。最终得到了一个行之有效的方法：</p></div><div class=listingblock><div class=title>main.smali</div><div class=content><pre class="prettyprint highlight"><code data-lang=smali>    #output _made_key -------------------------

    const-string v6, &#34;made_key.txt&#34;

    sput-object v6, LCom/zAWS/KeygenMe/main;-&gt;_file_name:Ljava/lang/String;

    invoke-static {v1}, LCom/zAWS/KeygenMe/main;-&gt;_write2file(Ljava/lang/String;)Ljava/lang/String;

    const-string v6, &#34;key.txt&#34;

    sput-object v6, LCom/zAWS/KeygenMe/main;-&gt;_file_name:Ljava/lang/String;

    #output _made_key -------------------------</code></pre></div></div><div class=paragraph><p>前两条命令将 <code>_file_name</code> 改为 <code>made_key.txt</code> ，调用 <code>_write2file()</code> 后再将 <code>_file_name</code> 改回 <code>key.txt</code> 。</p></div><div class=paragraph><p>注意，其中的 <code>v6</code> 寄存器是我新增加的寄存器，所以需要将 <code>.locals</code> 命令后参数加1。</p></div><div class=paragraph><p>将上述代码添加到</p></div><div class=literalblock><div class=content><pre>invoke-static {}, LCom/zAWS/KeygenMe/main;-&gt;_made_key()Ljava/lang/String;
move-result-object v1</pre></div></div><div class=paragraph><p>之后即可打印 <code>v1</code> 中的内容，查看 <code>_made_key()</code> 调用结果。</p></div><div class=paragraph><p>按照上述方法修改过main.smali后通过和前面软件破解一致的“重新打包、签名、安装”三步，即可运行软件查看 <code>_made_key()</code> 调用结果。</p></div><div class="imageblock text-center"><div class=content><img src=./made_key.png alt=made_key结果></div><div class=title>Figure 7. 查看 <code>_made_key()</code> 调用结果</div></div><div class=paragraph><p>以上过程所叙述的调试方法就是我这次逆向过程的“瑞士军刀”，是保证我重新实现的函数与原程序中完全一致的关键所在。</p></div></div><div class=sect3><h4 id=_imei和mac的获取>IMEI和MAC的获取</h4><div class=paragraph><p>在原程序中，IMEI通过</p></div><div class=literalblock><div class=content><pre>_imei = (phoneId = mostCurrent._myphone).GetDeviceId();</pre></div></div><div class=paragraph><p>获取；MAC通过</p></div><div class=literalblock><div class=content><pre>_mac_address = (mostCurrent._mywifi.ABGetCurrentWifiInfo()).MacAddress;</pre></div></div><div class=paragraph><p>获取。</p></div><div class=paragraph><p>事实上，我们用户都熟知，可以通过拨号盘输入“*#06#”获取IMEI，可以通过查看WiFi信息来获取MAC码。</p></div><div class="imageblock text-center"><div class=content><img src=./imei.png alt=获取IMEI，结果为358240051111110 width=60></div><div class=title>Figure 8. 获取IMEI，结果为358240051111110</div></div><div class="imageblock text-center"><div class=content><img src=./mac.png alt=获取MAC，结果为0215b2000000 width=60></div><div class=title>Figure 9. 获取MAC，结果为0215b2000000</div></div><div class=paragraph><p>在我一开始的设计中，由用户手动将IMEI和MAC写入注册机，点击“Compute” 按钮后计算出结果显示在“RegCode”一栏。</p></div><div class=paragraph><p>后面为了更自动化，我在程序中加入自动获取IMEI和MAC码的功能。</p></div><div class=sect4><h5 id=_小插曲>小插曲：</h5><div class=paragraph><p>在调试过程中，我发现原程序获得的MAC地址与模拟器实际显示的不一致</p></div><div class="imageblock text-center"><div class=content><img src=./check-mac.png alt=查看原程序获取到的MAC地址></div><div class=title>Figure 10. 查看原程序获取到的MAC地址</div></div><div class=paragraph><p>程序获得的MAC地址是 <code>02:00:00:00:00:00</code> 实际是 <code>02:15:b2:00:00:00</code></p></div><div class=paragraph><p>简而言之，原因是我的模拟器版本高于Android 6.0（M）由于Android 6.0 之后对于用户隐私的保护，将不再能通过 <code>WifiManager</code> 获取MAC，获取到的MAC将是固定的： <code>02:00:00:00:00:00</code> 。</p></div><div class=paragraph><p>详细分析原程序获取MAC的过程可以看到它正是通过 <code>WifiManager</code> 获取的MAC地址。</p></div><div class=listingblock><div class=title>ABWifi.java中的ABLoadWifi函数</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>WifiInfo wifiInfo = this.wifi.getConnectionInfo();// <b class=conum>(1)</b>
    String str1 = str2;
    if (wifiInfo != null) {
      this._CurrentWifiInfo.BSSID = wifiInfo.getBSSID();
      this._CurrentWifiInfo.MacAddress = wifiInfo.getMacAddress();// <b class=conum>(2)</b>
      this._CurrentWifiInfo.FullString = wifiInfo.toString();
//...</code></pre></div></div><div class="colist arabic"><ol><li><p><code>wifi</code> 是 <code>WifiManager</code> 对象</p></li><li><p>通过 <code>WifiInfo</code> 的 <code>getMacAddress()</code> 获取到MAC地址</p></li></ol></div><div class=paragraph><p>但这其实也简化了我编程的难度。我也只需要通过 <code>WifiManager</code> 获取MAC即可，不用考虑更高版本的适配了。</p></div><div class=paragraph><p>IMEI的获取方式较为类似，是通过 <code>TelephonyManager</code> 的 <code>getimei()</code> 或 <code>getDeviceId()</code> 函数得到的。 <code>getDeviceId()</code> 在Android 8.0 （O）及以上就被标明弃用了，改用 <code>getimei()</code> 函数，不过在模拟器中，原程序能够获得正确的IMEI。</p></div><div class="imageblock text-center"><div class=content><img src=./check-imei.png alt=查看原程序获取到的IMEI地址 width=75%></div><div class=title>Figure 11. 查看原程序获取到的IMEI地址</div></div></div></div><div class=sect3><h4 id=_calculate_codes_fix_imei_及_get_correct_code_函数><code>_calculate_codes()</code> ， <code>_fix_imei()</code> 及 <code>_get_correct_code()</code> 函数</h4><div class=paragraph><p>在 <code>_check_code()</code> 函数中，出去前面分析过的 <code>_decrypt()</code> 函数外，就是 <code>_calculate_codes()</code> ， <code>_fix_imei()</code> 及 <code>_get_correct_code()</code> 函数构成了主要部分。分析过程与前文中 <code>_made_key()</code> 函数的分析相同：先通过反编译的Java代码重新实现一遍对应的函数，再在原程序和注册机程序中输入相同的内容进行检验，原程序通过在smali代码中添加调试输出语句在 <code>adb shell</code> 中进行字符串的查看，注册机输出到 <code>RegCode</code> 右边的TextView中（当时截图时是TextView，现在我已经把这个改成了EditText方便复制，不过这些都是小细节了）,若输出一致，基本上可以判断重新实现的函数是正确的。</p></div><div class=paragraph><p>下面进行具体分析：</p></div><div class=sect4><h5 id=_decrypt_和_encrypt_函数的分析检验><code>_decrypt()</code> 和 <code>_encrypt()</code> 函数的分析检验。</h5><div class="imageblock text-center"><div class=content><img src=./check-key-2.png alt="check key 2" width=75%></div><div class=title>Figure 12. <code>_encrypt()</code> 函数，注册机检验输出的语句，输入为11个1</div></div><div class="imageblock text-center"><div class=content><img src=./check-key.png alt="check key" width=50%></div><div class=title>Figure 13. <code>_encrypt()</code> 函数输出对比</div></div><div class=paragraph><p>输出的内容是一致的。</p></div><div class="imageblock text-center"><div class=content><img src=./check-decrypt-2.png alt="check decrypt 2" width=75%></div><div class=title>Figure 14. <code>_decrypt()</code> 函数，注册机检验输出的语句，先加密在解密，加密输入为11个1</div></div><div class="imageblock text-center"><div class=content><img src=./check-decrypt.png alt="check decrypt" width=50%></div><div class=title>Figure 15. <code>_decrypt()</code> 函数输出</div></div><div class=paragraph><p>成功将输入的字符串（11个1）解密</p></div></div><div class=sect4><h5 id=_calculate_codes_和_fix_imei_的检验><code>_calculate_codes()</code> 和 <code>_fix_imei()</code> 的检验</h5><div class=paragraph><p>（说一个细节：反编译出的代码中“calculate”一词拼写错误，我后续做了修改）</p></div><div class="imageblock text-center"><div class=content><img src=./check-str1-2.png alt="check str1 2" width=75%></div><div class=title>Figure 16. <code>_calculate_codes(_fix_imei(true))</code> 的结果（即 <code>str1</code> ）注册机检验输出的语句</div></div><div class=paragraph><p>注意到我截图时加上了前面的 <code>_array_p1</code> 初始化赋值语句，这很重要，否则计算失败。</p></div><div class="imageblock text-center"><div class=content><img src=./check-str1.png alt="check str1" width=50%></div><div class=title>Figure 17. <code>_calculate_codes(_fix_imei(true))</code> 的结果（即 <code>str1</code> ）输出结果对比</div></div><div class="imageblock text-center"><div class=content><img src=./check-str2-2.png alt="check str2 2" width=75%></div><div class=title>Figure 18. <code>_calculate_codes(_fix_imei(false))</code> 的结果（即 <code>str2</code> ）注册机检验输出的语句</div></div><div class="imageblock text-center"><div class=content><img src=./check-str2.png alt="check str2" width=50%></div><div class=title>Figure 19. <code>_calculate_codes(_fix_imei(false))</code> 的结果（即 <code>str2</code> ）输出结果对比</div></div><div class="imageblock text-center"><div class=content><img src=./check-key_from_imei_number-2.png alt={75-width}></div><div class=title>Figure 20. key_from_imei_number检验</div></div><div class=paragraph><p>这个字符串容易被忽略，我在下面用 <code>s_imei</code> 表示 <code>_key_from_imei_number</code> 转成的字符串。</p></div><div class="imageblock text-center"><div class=content><img src=./check-key_from_imei_number.png alt="check key from imei number" width=50%></div><div class=title>Figure 21. key_from_imei_number检验</div></div></div><div class=sect4><h5 id=_get_correct_code_函数分析><code>_get_correct_code()</code> 函数分析</h5><div class=listingblock><div class=content><pre class="prettyprint highlight"><code data-lang=java>public static String _get_correct_code(String paramString){
        String str1 = paramString.substring(0, 5);//0,1,2,3,4
        String str2 = paramString.substring(paramString.length() - 5);//6,7,8,9,10
        paramString = paramString.substring(5, 6);//5
        return paramString + str2 + str1;//5,6,7,8,9,10,0,1,2,3,4
}</code></pre></div></div><div class=paragraph><p>这个函数非常简单，一目了然，就是将输入的字符串（ <code>str3</code> ,长度是11）从第六个字符（下标是5）开始一直到最后一个字符形成的子串拿到前面来，即：按照下标为5,6,7,8,9,10,0,1,2,3,4的顺序重新排列。</p></div></div></div><div class=sect3><h4 id=_收尾工作>收尾工作</h4><div class=paragraph><p>分析至此，我们的工作已经基本成功了。</p></div><div class=paragraph><p>在 <code>_check_code</code> 中的三个if条件告诉了我们如何组合几个字符串能满足成功注册的条件</p></div><div class=listingblock><div class=title>_check_code() 函数</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>if (!str3.substring(0, 1).equalsIgnoreCase(stringBuilderWrapper.Append(BA.NumberToString(_key_from_imei_number)).ToString().valueOf(stringBuilderWrapper)))
	return false;
if (!str3.substring(1, 6).equalsIgnoreCase(str1))
	return false;
if (!str3.substring(str3.length() - 5, str3.length()).equalsIgnoreCase(str2))
	return false;</code></pre></div></div><div class=listingblock><div class=title>最终我的注册机核心代码</div><div class=content><pre class="prettyprint highlight"><code data-lang=java>String str1,str2,str3,s_imei;
str1 = _calculate_codes(_fix_imei(true));
str2 = _calculate_codes(_fix_imei(false));
s_imei = NumberToString(_key_from_imei_number);
str3 = s_imei+str1+str2;
str3 = _recombine_code(str3);
TW_RegCodeText.setText(str3);</code></pre></div></div><div class=paragraph><p>其中 <code>str3</code> 用以表示结果（即用户应输入的11位数字的注册码），其它的各变量和函数的含义在上面均以详细讲述过了。</p></div><div class=paragraph><p>最后的效果是成功注册，小黄锁打开了。图我就不上了，因为和前面软件破解后的效果一样。</p></div><div class=paragraph><p>但我录了一个小视频， <code>success.gif</code></p></div><div class=imageblock><div class=content><img src=./success.gif alt=success.gif></div></div></div></div></div></div><div class=sect1><h2 id=_文件夹内容说明>文件夹内容说明</h2><div class=sectionbody><div class="olist arabic"><ol class=arabic><li><p><code>crackme2-selfsigned.apk</code> 文件是第一题软件破解后自签名程序</p></li><li><p><code>Reg.apk</code> 文件是第二题的注册机程序</p></li><li><p><code>pic</code> 目录中包含本文中的所有图片</p></li><li><p><code>success.gif</code> 文件是注册机使用效果录屏</p></li><li><p><code>Reg</code> 目录下是注册机项目源码</p></li></ol></div></div></div></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><footer class=site-footer><section class=copyright>&copy;
2019 -
2025 cld4h 的博客</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.26.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>