[{"content":"VS Code allows us to connect to a remote envirnoment. This is very convenient especially for developing and testing code on cloud computing servers.\nHowever, starting with VS Code release 1.99 (March 2025), the prebuilt servers distributed by VS Code are only compatible with Linux distributions that are based on glibc 2.28 or later.\nThis create connection problems for users of Compute Canada. Specifically, connections to Graham and Niagara because of the no longer supported CentOS7 system.\nIn this article, I\u0026rsquo;ll show you all the steps I\u0026rsquo;ve done to establish a Remote Tunnel and connect to the server.\nOfficial Workaround (which is not fully working) Firstly I followed the VS Code official documentation, to prepare a sysroot, a patchelf and set the three environment variables.\nLong story short, it did not solve the problem but we still need these steps.\nI don\u0026rsquo;t want to repeate the steps mentioned in their official documentation, but several pitfalls worth mentioning:\nBuild and run the crosstool-ng command ct-ng build on a docker environment (the Dockerfile is provided on the documentation ), and compress the output x86_64-linux-gnu to send it to the server. Set the 3 environment variables in $HOME/.bash_profile (Here I put the output from ct-ng build (the extracted x86_64-linux-gnu folder) under $HOME/.local/share) 1 2 3 export VSCODE_SERVER_CUSTOM_GLIBC_LINKER=$HOME/.local/share/x86_64-linux-gnu/x86_64-linux-gnu/sysroot/lib64/ld-linux-x86-64.so.2 export VSCODE_SERVER_CUSTOM_GLIBC_PATH=$HOME/.local/share/x86_64-linux-gnu/x86_64-linux-gnu/sysroot/lib64 export VSCODE_SERVER_PATCHELF_PATH=$HOME/.local/bin/patchelf Remote tunnels After failure of the official workarounds from VS Code, I noticed the suggestions from The Alliance wiki:\nuse the \u0026ldquo;Remote Tunnels\u0026rdquo; extension by running \u0026lsquo;code tunnel\u0026rsquo; (google vscode cli and download it). Use github or a microsoft account (OAuth) and connect to a remote vscode server, such as a niagara login node. You can have all the \u0026ldquo;benefits\u0026rdquo; of not using mfa as long as your server is running.\nFirst thing is to download the VS Code CLI\n1 2 3 wget -O vscode-cli.tar.gz \u0026#34;https://code.visualstudio.com/sha/download?build=stable\u0026amp;os=cli-alpine-x64\u0026#34; tar -xzvf vscode-cli.tar.gz -C $HOME/.local/bin/ rm vscode-cli.tar.gz On remote server, run code tunnel to start.\nMake sure environment variables (echo $VSCODE_SERVER_CUSTOM_GLIBC_PATH to check) are set from previous steps. Otherwise you\u0026rsquo;ll get an error like this:\nManually download the vscode server package If you try to connect to the remote now, you will see the remote server keep crashing and on the remote server, vscode keeps downloading and extracting the server package.\nWhat is the reason for this issue?\nThere must be some errors when we are trying to run the vscode server script.\nCan we run it manually?\nHere @cvcore provided a script for manually downloading the vscode-server\nTo run that script, we need to know the commit_id.\nGo to your VS Code Client, on the top menu tabs, go to Help-\u0026gt;About and you can see the commit id.\n1 /bin/bash -c \u0026#34;$(curl -fsSL https://gist.githubusercontent.com/cvcore/8e187163f41a77f5271c26a870e52778/raw/download_vscode_server.sh)\u0026#34; -- \u0026lt;commit_id\u0026gt; Replace \u0026lt;commit_id\u0026gt; with your actual commit id, run this command and it will download the vscode-server into your $HOME/.vscode-server/bin/\u0026lt;commit_id\u0026gt; folder.\nRun vscode-server manually Now with the server downloaded in $HOME/.vscode-server/bin/\u0026lt;commit_id\u0026gt;, we can try to run it manually. But there will be an issue:\nIf you run the server with environment variables set, you can see the patchelf working but we still get an error:\nIf you run the server without environment variables set, you\u0026rsquo;ll also get an error:\nHere is the SOLUTION to this problem. On the alliance wiki, it says:\nIf you install pre-compiled binaries in your home directory they may fail using errors such as /lib64/libc.so.6: version 'GLIBC_2.18' not found. Often such binaries can be patched using our setrpaths.sh script, using the syntax setrpaths.sh --path path [--add_origin] where path refers to the directory where you installed that software.\nThe setrpaths.sh is hosted on their github repo here but you don\u0026rsquo;t need to download it. It\u0026rsquo;s in your PATH under the folder /cvmfs/soft.computecanada.ca/easybuild/bin/\nSo here we simply run the following command (replace \u0026lt;commit_id\u0026gt; with the actual one):\n1 setrpaths.sh --path $HOME/.vscode-server/bin/\u0026lt;commit_id\u0026gt; Modify the startup script From the last step, we start the server from executing ./code-server. This is just a shell script wrapping the node-js server executable:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #!/usr/bin/env sh # # Copyright (c) Microsoft Corporation. All rights reserved. # case \u0026#34;$1\u0026#34; in --inspect*) INSPECT=\u0026#34;$1\u0026#34;; shift;; esac ROOT=\u0026#34;$(dirname \u0026#34;$(dirname \u0026#34;$(readlink -f \u0026#34;$0\u0026#34;)\u0026#34;)\u0026#34;)\u0026#34; # Set rpath before changing the interpreter path # Refs https://github.com/NixOS/patchelf/issues/524 if [ -n \u0026#34;$VSCODE_SERVER_CUSTOM_GLIBC_LINKER\u0026#34; ] \u0026amp;\u0026amp; [ -n \u0026#34;$VSCODE_SERVER_CUSTOM_GLIBC_PATH\u0026#34; ] \u0026amp;\u0026amp; [ -n \u0026#34;$VSCODE_SERVER_PATCHELF_PATH\u0026#34; ]; then echo \u0026#34;Patching glibc from $VSCODE_SERVER_CUSTOM_GLIBC_PATH with $VSCODE_SERVER_PATCHELF_PATH...\u0026#34; \u0026#34;$VSCODE_SERVER_PATCHELF_PATH\u0026#34; --set-rpath \u0026#34;$VSCODE_SERVER_CUSTOM_GLIBC_PATH\u0026#34; \u0026#34;$ROOT/node\u0026#34; echo \u0026#34;Patching linker from $VSCODE_SERVER_CUSTOM_GLIBC_LINKER with $VSCODE_SERVER_PATCHELF_PATH...\u0026#34; \u0026#34;$VSCODE_SERVER_PATCHELF_PATH\u0026#34; --set-interpreter \u0026#34;$VSCODE_SERVER_CUSTOM_GLIBC_LINKER\u0026#34; \u0026#34;$ROOT/node\u0026#34; echo \u0026#34;Patching complete.\u0026#34; fi \u0026#34;$ROOT/node\u0026#34; ${INSPECT:-} \u0026#34;$ROOT/out/server-main.js\u0026#34; \u0026#34;$@\u0026#34; Here you can see from line 14 to 20, it checkes the environment variables to patch glic and linker. We don\u0026rsquo;t need that so comment out or remove those lines. Otherwise, by default, with 3 environment variables set, patching will be done and we will get the FATAL: kernel too old error.\nPrepare everything in the correct path (replace \u0026lt;commit_id\u0026gt; with the actual one)\n1 2 3 4 5 6 7 8 COMMIT_ID=\u0026lt;commit_id\u0026gt; rm -rf $HOME/.vscode mkdir -p $HOME/.vscode/cli/servers/Stable-$COMMIT_ID cat \u0026lt;\u0026lt; EOF \u0026gt; $HOME/.vscode/cli/servers/lru.json [\u0026#34;Stable-$COMMIT_ID\u0026#34;] EOF cp -r $HOME/.vscode-server/bin/$COMMIT_ID $HOME/.vscode/cli/servers/Stable-$COMMIT_ID/server Now you can start a tmux session and run code tunnel to start the server.\nResults ","date":"2025-05-16T00:00:00Z","permalink":"https://cld4h.github.io/blog/p/workaround-vscode-remote-on-compute-canada-centos7-server/","title":"Workaround: VSCode Remote on Compute Canada CentOS7 Server"},{"content":"A few days ago, I got a MacBook Air (mid 2011) from a friend. The battery was died, but everything else is fine, despite it running extremly slowly.\nI tried to reinstall an older version of OS X system for it.\nThe first thing is to create a bootable USB drive for that. Following the instructions here and here, I\u0026rsquo;ve done this successfully.\nIt\u0026rsquo;s a completely a new (and a little complicated) experience for me. So I felt it\u0026rsquo;s necessary to write up the steps.\nPreparation dmg2img (in AUR) to convert Apple\u0026rsquo;s .dmg image format to .img kpartx (in multipath-tools package) to mount .img xar (in AUR) to extract .pkg InstallMacOSX.dmg or InstallESD.dmg A USB drive (refered to as /dev/sdX in the following contents) Steps Extract InstallESD.dmg from InstallMacOSX.dmg Do the following steps: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 mkdir -p /mnt/OSX_InstallESD /mnt/OSX_BaseSystem /mnt/usbstick # convert installer disk image to raw format dmg2img \u0026#34;Install OS X \u0026lt;Version\u0026gt;.app/Contents/SharedSupport/InstallESD.dmg\u0026#34; InstallESD.img kpartx -a InstallESD.img mount /dev/mapper/loop0p2 /mnt/OSX_InstallESD # convert base system disk image to raw format dmg2img /mnt/OSX_InstallESD/BaseSystem.dmg BaseSystem.img kpartx -a BaseSystem.img mount /dev/mapper/loop1p1 /mnt/OSX_BaseSystem # partition the USB flash drive, /dev/sdX sgdisk -o /dev/sdX sgdisk -n 1:0:0 -t 1:AF00 -c 1:\u0026#34;disk image\u0026#34; -A 1:set:2 /dev/sdX mkfs.hfsplus -v \u0026#34;OS X Base System\u0026#34; /dev/sdX1 mount /dev/sdX1 /mnt/usbstick # copy installer files rsync -aAEHW /mnt/OSX_BaseSystem/ /mnt/usbstick/ rm -f /mnt/usbstick/System/Installation/Packages rsync -aAEHW /mnt/OSX_InstallESD/Packages /mnt/usbstick/System/Installation/ rsync -aAEHW /mnt/OSX_InstallESD/BaseSystem.chunklist /mnt/usbstick/ rsync -aAEHW /mnt/OSX_InstallESD/BaseSystem.dmg /mnt/usbstick/ sync In the final step, sync is to write all cached writes to persistent storage. It can go extremly slowly. To see the progress, you can look at /proc/meminfo to see Dirty sizes.\n1 watch -d grep -e Dirty: -e Writeback: /proc/meminfo (reference)\n","date":"2023-05-10T14:05:43+08:00","permalink":"https://cld4h.github.io/blog/p/making-a-bootable-macos-x-usb-on-archlinux/","title":"Making a bootable MacOS X USB on Archlinux"},{"content":"This article show you the ultimate way to set up a transparent proxy on Linux using clash and iptables to bypass the GFW in China.\nWe use:\nclash as the proxy software online subconverter and crontab to periodically update config file. ACL4SSR to provide GFW rules. You can go to github gist to download all files mentioned in this article.\nAll files you need:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 . ├── clash-base-config.yaml ---🟢base config for clash to work on tproxy and fake-ip mode ├── clash.service ---🟢systemd unit file to start up clash ├── clean.sh ---🟢script to clean iptables ├── config.ini ---🟢config file for subconverter ├── iptables.sh ---🟢iptables config file ├── update-config.sh ---🟡subscription update script; \u0026#34;XXXXXXXX\u0026#34; need to be replaced ├── config.yaml ---⭕clash config file, to be generated from update-config.sh ├── README.md └── README.zh-cn.md 🟢: Doesn\u0026#39;t need to change 🟡: Needs to change ⭕: Needs to be generated Reference clash-tproxy\nTransparent proxy demo code\nPrerequisite a clash installed. (By default in /usr/bin/clash) iptables systemd (It\u0026rsquo;s totally fine to use other init programs, but here I\u0026rsquo;ll only show the configuration of systemd, which is the default of most GNU/Linux distros.) crontab Steps Create a system user called clash 1 useradd -r -M -s /usr/sbin/nologin clash Since we want to proxy all internet traffics, we need to prevent the traffic from looping. Thus, we create a distinct user called clash (the name can be arbitrary) to run the proxy software clash. We\u0026rsquo;ll make an iptables rule in the following steps to distinguish traffic coming from the user clash.\nCreate iptables and routing rules Create a shell script of iptables command called /etc/clash/iptables.sh.\nThe file contains 3 main sections:\niptables rules to hijack the dns query traffic, config for clash chain config for clash_local chain iptables:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ┌─────────┐ ┌─────────┐ │ │ PREROUTING INPUT │ │ │ │ │ │ │ │ ┌─────────────────────────────────────┐ ┌────────────────────┐ │ │ │ │ │ │ /───\\ │ │ │ │ │ │ │ ┌───┐ ┌─────────┐ ┌──────┐ ┌───┐ │ / \\ │ ┌──────┐ ┌──────┐ │ │ │ │ ├──┤►│raw├─►│conntrack├─►│mangle├─►│nat├─┼──────►\u0026lt;routing\u0026gt;──────┤►│mangle├─►│filter├─┤►│ │ │ │ │ └───┘ └─────────┘ └──────┘ └───┘ │ \\ / │ └──────┘ └──────┘ │ │ │ │ │ │ │ \\─┬─/ │ │ │ │ │ │ └─────────────────────────────────────┘ │ └────────────────────┘ │ │ │ │ │ │ │ │ │ ┌──────────┐ │ │ │ │ │ │ │ │ │ │ │ │ │ ┌──────┐ │ │ │ │ │ │ │ │mangle◄─┼─────────┘ │ │ │ Network │ │ └──┬───┘ │ │ Local │ │Interface│ │ │ │ FORWARD │ Process │ │ │ │ ┌──▼───┐ │ /───\\ │ │ │ │ ┌───────────────┼─┤filter│ │ / \\ │ │ │ │ │ │ └──────┘ │ \u0026lt;routing\u0026gt;◄─┤ │ │ │ │ │ │ \\ / │ │ │ │ │ └──────────┘ \\─┬─/ │ │ │ │ │ │ │ │ │ │ ┌────────────┼────┐ ┌──────────────────────────────────────────┼────┐ │ │ │ │ │ │ │ ───── │ │ │ │ │ │ │ │ ┌───┐ ┌───▼──┐ │ / \\ │ ┌──────┐ ┌───┐ ┌──────┐ ┌─────────┐ ┌▼──┐ │ │ │ │ │◄─┼─┤nat│◄─┤mangle│◄├───\u0026lt;reroute\u0026gt;───┼─┤filter│◄─┤nat│◄─┤mangle│◄─┤conntrack│◄─┤raw│ │ │ │ │ │ │ └───┘ └──────┘ │ \\check/ │ └──────┘ └───┘ └──────┘ └─────────┘ └───┘ │ │ │ │ │ │ │ ───── │ │ │ │ │ │ └─────────────────┘ └───────────────────────────────────────────────┘ │ │ │ │ POSTROUTING OUTPUT │ │ │ │ │ │ └─────────┘ └─────────┘ /etc/clash/iptables.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #!/usr/bin/env bash # set -ex options: # -e Exit immediately if a command exits with a non-zero status # -x Print commands and their arguments as they are executed. set -ex # ENABLE ipv4 forward sysctl -w net.ipv4.ip_forward=1 # ROUTE RULES ip rule add fwmark 666 table 666 ip route add local 0.0.0.0/0 table 666 dev lo ################################## ## hijack the dns query traffic ## ################################## # Redirect all dns query traffic from LAN to port 1053 # Later clash will return a fake ip in 198.18.0.1/16 iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 # same for ipv6 ip6tables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 # Redirect dns query traffic from all local processes (except owned by user clash) to port 1053 # Later clash will return a fake ip in 198.18.0.1/16 iptables -t nat -N clash_dns iptables -t nat -A OUTPUT -p udp --dport 53 -j clash_dns iptables -t nat -A clash_dns -m owner --uid-owner clash -j RETURN iptables -t nat -A clash_dns -p udp -j REDIRECT --to-ports 1053 # same for ipv6 ip6tables -t nat -N clash_dns ip6tables -t nat -A OUTPUT -p udp --dport 53 -j clash_dns ip6tables -t nat -A clash_dns -m owner --uid-owner clash -j RETURN ip6tables -t nat -A clash_dns -p udp -j REDIRECT --to-ports 1053 ############################## ## config for `clash` chain ## ############################## # `clash` chain for using tproxy to redirect traffic to the clash listening port 7893 iptables -t mangle -N clash # skip traffic to LAN or reserved address # reference: # https://en.wikipedia.org/wiki/List_of_assigned_/8_IPv4_address_blocks # https://en.wikipedia.org/wiki/Private_network#IPv4 # IANA - Local Identification iptables -t mangle -A clash -d 0.0.0.0/8 -j RETURN # IANA - Loopback iptables -t mangle -A clash -d 127.0.0.0/8 -j RETURN # IANA - Private Use iptables -t mangle -A clash -d 10.0.0.0/8 -j RETURN iptables -t mangle -A clash -d 172.16.0.0/12 -j RETURN iptables -t mangle -A clash -d 192.168.0.0/16 -j RETURN # IPv4 Link-Local Addresses iptables -t mangle -A clash -d 169.254.0.0/16 -j RETURN # Multicast iptables -t mangle -A clash -d 224.0.0.0/4 -j RETURN # Future Use iptables -t mangle -A clash -d 240.0.0.0/4 -j RETURN # Forward all the other traffic to port 7893 and set tproxy mark iptables -t mangle -A clash -p tcp -j TPROXY --on-port 7893 --tproxy-mark 666 iptables -t mangle -A clash -p udp -j TPROXY --on-port 7893 --tproxy-mark 666 # Append the `clash` chain to PREROUTING to enable it iptables -t mangle -A PREROUTING -j clash #################################### ## config for `clash_local` chain ## #################################### # `clash_local` chain to manipulate the traffic from local process: set fwmark 666 on traffic to public address # (which will later reroute to dev lo, then redirect to tproxy port 7893 on the `clash` chain of `PREROUTING`) iptables -t mangle -N clash_local # rerouting traffic from nerdctl container #iptables -t mangle -A clash_local -i nerdctl2 -p udp -j MARK --set-mark 666 #iptables -t mangle -A clash_local -i nerdctl2 -p tcp -j MARK --set-mark 666 # Don\u0026#39;t touch traffic to LAN and reserved address iptables -t mangle -A clash_local -d 0.0.0.0/8 -j RETURN iptables -t mangle -A clash_local -d 127.0.0.0/8 -j RETURN iptables -t mangle -A clash_local -d 10.0.0.0/8 -j RETURN iptables -t mangle -A clash_local -d 172.16.0.0/12 -j RETURN iptables -t mangle -A clash_local -d 192.168.0.0/16 -j RETURN iptables -t mangle -A clash_local -d 169.254.0.0/16 -j RETURN iptables -t mangle -A clash_local -d 224.0.0.0/4 -j RETURN iptables -t mangle -A clash_local -d 240.0.0.0/4 -j RETURN # set mark for local traffic # clash_local set mark for the traffic from local process, # the marked traffic will come back to PREROUTING chain. iptables -t mangle -A clash_local -p tcp -j MARK --set-mark 666 iptables -t mangle -A clash_local -p udp -j MARK --set-mark 666 # Don\u0026#39;t touch traffic from a serving port # https web server # iptables -t mangle -I OUTPUT -p tcp --sport 443 -j RETURN # transmission # iptables -t mangle -I OUTPUT -p tcp --sport 51413 -j RETURN # Don\u0026#39;t touch traffic from the user `clash` to prevent looping iptables -t mangle -A OUTPUT -p tcp -m owner --uid-owner clash -j RETURN iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner clash -j RETURN # Append the `clash_local` chain to OUTPUT to enable it iptables -t mangle -A OUTPUT -j clash_local ####################### ## unimportant staff ## ####################### # fix ICMP(ping) # This step does NOT make the ping result validate # (clash doesn\u0026#39;t support forwarding ICMP), it just makes ping have a result. # set --to-destination to a accessable address. #sysctl -w net.ipv4.conf.all.route_localnet=1 #iptables -t nat -A PREROUTING -p icmp -d 198.18.0.0/16 -j DNAT --to-destination 127.0.0.1 #iptables -t nat -A OUTPUT -p icmp -d 198.18.0.0/16 -j DNAT --to-destination 127.0.0.1 After applying the script above, the system iptables should be like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ┌─────────┐ ┌─────────┐ │ │ PREROUTING rule1* INPUT │ │ │ │ │ │ │ │ │ ┌─────────────────────────────────┼───┐ ┌────────────────────┐ │ │ │ │ │ │ │ /───\\ │ │ │ │ │ │ │ ┌───┐ ┌─────────┐ ┌──────┐ ┌─┴─┐ │ / \\ │ ┌──────┐ ┌──────┐ │ │ │ │ ├──┤►│raw├─►│conntrack├─►│mangle├─►│nat├─┼──────►\u0026lt;routing\u0026gt;──────┤►│mangle├─►│filter├─┤►│ │ │ │ │ └───┘ └─────────┘ └┬─────┘ └───┘ │ \\ / │ └──────┘ └──────┘ │ │ │ │ │ │ │ │ \\─┬─/ │ │ │ │ │ │ └──────────────────────┼──────────────┘ │ └────────────────────┘ │ │ │ │ │ │ │ │ │ │ ┌──┴──┐ ┌──────────┐ │ │ │ │ │ │clash│ │ │ │ │ │ │ │ └─────┘ │ ┌──────┐ │ │ │ │ │ │ │ │mangle◄─┼─────────┘ │ │ │ Network │ │ └──┬───┘ │ ┌───────────┐ │ Local │ │Interface│ │ │ │ FORWARD │clash_local│ │ Process │ │ │ │ ┌──▼───┐ │ └─┬─────────┘ /───\\ │ │ │ │ ┌───────────────┼─┤filter│ │ │ / \\ │ │ │ │ │ │ └──────┘ │ ├───rule3* \u0026lt;routing\u0026gt;◄─┤ │ │ │ │ │ │ │ \\ / │ │ │ │ │ └──────────┘ ├───rule2* \\─┬─/ │ │ │ │ │ │ │ │ │ │ │ ┌────────────┼────┐ ┌──────────────────────┼───────────────────┼────┐ │ │ │ │ │ │ │ ───── │ │ │ │ │ │ │ │ │ ┌───┐ ┌───▼──┐ │ / \\ │ ┌──────┐ ┌───┐ ┌───┴──┐ ┌─────────┐ ┌▼──┐ │ │ │ │ │◄─┼─┤nat│◄─┤mangle│◄├───\u0026lt;reroute\u0026gt;───┼─┤filter│◄─┤nat│◄─┤mangle│◄─┤conntrack│◄─┤raw│ │ │ │ │ │ │ └───┘ └──────┘ │ \\check/ │ └──────┘ └┬──┘ └──────┘ └─────────┘ └───┘ │ │ │ │ │ │ │ ───── │ │ │ │ │ │ │ └─────────────────┘ └────────────┼──────────────────────────────────┘ │ │ │ │ POSTROUTING │ OUTPUT │ │ │ │ ┌──────┴──┐ │ │ └─────────┘ │clash_dns│ └─────────┘ └─────────┘ *rule1: iptables -t nat -I PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 *rule2: iptables -t mangle -A OUTPUT -p tcp -m owner --uid-owner clash -j RETURN *rule3: iptables -t mangle -A OUTPUT -p udp -m owner --uid-owner clash -j RETURN It\u0026rsquo;s also worth to take a look at the route rules in iptables.sh:\n1 2 ip rule add fwmark 666 table 666 ip route add local 0.0.0.0/0 table 666 dev lo ip rule manipulates rules in the routing policy database control the route selection algorithm.\nSo here the ip rule command make the kernel to lookup table 666 for packets with fwmark 666\nip rule reference is here.\nThe ip route command add a default route to device lo on routing table 666.\nWe can use ip route show table 666 to see the route added by ip route add local 0.0.0.0/0 table 666 dev lo See the route table value and name mapping: cat /etc/iproute2/rt_tables\nCreate a cleaning script Create a shell script to clean the iptables.\n-D or --delete:\nDelete one or more rules from the selected chain. There are two versions of this command: the rule can be specified as a number in the chain (starting at 1 for the first rule) or a rule to match.\n-F or --flush:\nFlush the selected chain (all the chains in the table if none is given). This is equivalent to deleting all the rules one by one.\n-X or --delete-chain:\nDelete the optional user-defined chain specified. There must be no references to the chain. If there are, you must delete or replace the referring rules before the chain can be deleted. The chain must be empty, i.e. not contain any rules. If no argument is given, it will attempt to delete every non-builtin chain in the table.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env bash set -ex ip rule del fwmark 666 table 666 || true ip route del local 0.0.0.0/0 table 666 dev lo || true iptables -t nat -D PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 || true ip6tables -t nat -D PREROUTING -p udp --dport 53 -j REDIRECT --to 1053 || true iptables -t nat -D OUTPUT -p udp --dport 53 -j clash_dns || true ip6tables -t nat -D OUTPUT -p udp --dport 53 -j clash_dns || true iptables -t nat -F clash_dns || true iptables -t nat -X clash_dns || true ip6tables -t nat -F clash_dns || true ip6tables -t nat -X clash_dns || true #iptables -t nat -D PREROUTING -p icmp -d 198.18.0.0/16 -j DNAT --to-destination 127.0.0.1 #iptables -t nat -D OUTPUT -p icmp -d 198.18.0.0/16 -j DNAT --to-destination 127.0.0.1 iptables -t mangle -D PREROUTING -j clash || true iptables -t mangle -F clash || true iptables -t mangle -X clash || true iptables -t mangle -D OUTPUT -p tcp -m owner --uid-owner clash -j RETURN || true iptables -t mangle -D OUTPUT -p udp -m owner --uid-owner clash -j RETURN || true iptables -t mangle -D OUTPUT -j clash_local || true iptables -t mangle -F clash_local || true iptables -t mangle -X clash_local || true Fixing ping One major drawback of the fake-ip mode is that you can\u0026rsquo;t ping a fake ip.\nThe solution above to redirect all ping request to the localhost is \u0026ldquo;掩耳盗铃\u0026rdquo;, it doesn\u0026rsquo;t provide any useful information.\nSadly, all devices from LAN can\u0026rsquo;t use ping, but fortunately you can alias ping to sudo -u clash ping for this gateway to use ping.\n1 alias ping=\u0026#34;sudo -u clash ping\u0026#34; Provide a systemd unit file to start clash at a single command This step is optional, but I felt it\u0026rsquo;s extremely convenient to start clash by running a single command.\nYou can also make clash start at boot time.\nThe systemd config file is in the appended files with the name clash.service\nput it under /usr/lib/systemd/system, and run sudo systemctl start clash to start running clash.\nTo start it at boot time, run sudo systemctl enable clash.\nConfiguring clash Now let\u0026rsquo;s set clash up to work.\nClash use -d option to set configuration directory and -f option to specify configuration file.\nThe default configuration file name is config.yaml when -f is omitted.\nWe want to use crontab to periodically update the clash config from a subscription url.\nConstruct the subscription URL TL;DR. Just replace XXXXXXXX with your encoded subscription URL .\n1 https://sub.xeton.dev/sub?target=clash\u0026amp;new_name=true\u0026amp;filename=config.yaml\u0026amp;url=XXXXXXXX\u0026amp;config=https%3A%2F%2Fgist.githubusercontent.com%2Fcld4h%2F9a03ec2f826a25be5ab974fdbc540de4%2Fraw%2Fconfig.ini We use subconverter to generate config file for clash.\nYou need to change a few parameters in the subscription URL to generate a proper config file for clash to work in fake-ip mode.\nTo be specific:\nthe url parameter should be the correct subscription URL and encoded. Multiple subscription URL should be seperated by |, or %7C after URL Encoding. the config parameter should point to a correct configuration file. ⚠️ ⚠️ NOTICE: the configuration file for subconverter is extremely important!\nACL4SSR project provide a default configuration file for subconverter, it\u0026rsquo;s fine but NOT ENOUGH for clash to work on fake-ip mode.\nTo make it work, you need specify clash_rule_base by inserting this line to the configuration file for subconverter\n1 clash_rule_base=https://gist.githubusercontent.com/cld4h/9a03ec2f826a25be5ab974fdbc540de4/raw/clash-base-config.yaml What this line does is that it tells the subconverter to use the file in the url above instead of the default clash base configuration.\nOr you can just use the config.ini here\nSample url:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 https://sub.xeton.dev/sub? --- backend address target=clash --- client type \u0026amp;new_name=true --- create a new filename \u0026amp;filename=config.yaml --- filename \u0026amp;url= --- Node info ss%3A%2F%2FYmYtY2ZiOnRlc3QvIUAjOkAxOTIuMTY4LjEwMC4xOjg4ODg%23example-server %7C --- the delimiter | to seperate multiple urls ss%3A%2F%2FYmYtY2ZiOnRlc3QvIUAjOkAxOTIuMTY4LjEwMC4xOjg4ODg%23example-server-2 \u0026amp;config= --- config file for subconverter; .ini format https%3A%2F%2Fgist.githubusercontent.com%2Fcld4h%2F9a03ec2f826a25be5ab974fdbc540de4%2Fraw%2Fconfig.ini --- options below is unnecessary and can be omitted \u0026amp;list=false --- 用于输出 Surge Node List 或者 Clash Proxy Provider 或者 Quantumult (X) 的节点订阅 或者 解码后的 SIP002 \u0026amp;tfo=false --- 用于开启该订阅链接的 TCP Fast Open，默认为 false \u0026amp;scv=false --- 用于关闭 TLS 节点的证书检查，默认为 false \u0026amp;fdn=false --- 用于过滤目标类型不支持的节点，默认为 true \u0026amp;sort=false --- 用于对输出的节点或策略组按节点名进行再次排序，默认为 false Set up a cronjob Create a shell script /etc/clash/update-config.sh with the following content:\n1 2 3 #!/usr/bin/env bash set -ex /usr/bin/curl \u0026#34;https://sub.xeton.dev/sub?target=clash\u0026amp;new_name=true\u0026amp;filename=config.yaml\u0026amp;url=XXXXXXXX\u0026amp;config=https%3A%2F%2Fgist.githubusercontent.com%2Fcld4h%2F9a03ec2f826a25be5ab974fdbc540de4%2Fraw%2Fconfig.ini\u0026#34; -o /etc/clash/config.yaml ⚠️ The URL should be replace.\nManually executing it to make sure the config file is generated successfully.\nMake sure you have the following contents in your config.yaml file for clash:\n1 2 3 4 5 6 7 tproxy-port: 7893 dns: enable: true listen: 0.0.0.0:1053 enhanced-mode: fake-ip fake-ip-range: 198.18.0.1/16 Add a cronjob by executing sudo crontab -e and add this line to executing the script at 10:00 AM every day.\n1 0 10 * * * /usr/bin/bash /etc/clash/update-config.sh ","date":"2022-05-04T16:19:40+08:00","image":"https://cld4h.github.io/blog/p/the-ultimate-way-to-bypass-gfw-on-linux/iptables_hu_dd0f83ae4988a70a.webp","permalink":"https://cld4h.github.io/blog/p/the-ultimate-way-to-bypass-gfw-on-linux/","title":"The Ultimate Way to Bypass GFW on Linux"},{"content":"我回来啦！\n将hugo换了一个主题，从原来文档类的主题learn 换成了stack。\n毕竟在当下这种风声鹤唳的言论环境中，也就能写点技术类的东西。 本来平时看文档就要看吐了，个人博客何苦还要搞个大文档出来呢？\n文章还是要多写的，以防丧失语言能力。\n我计划以后每天（至少每周）都要写点东西。\n至少把自己想了点啥、干了点啥记下来，晚上就能睡个好觉了。\n","date":"2022-02-11T11:43:02+08:00","permalink":"https://cld4h.github.io/blog/p/im-back/","title":"I'm Back"},{"content":" Name http rss Luke Smith https://lukesmith.xyz https://lukesmith.xyz/rss.xml Luke Smith (peertube) https://videos.lukesmith.xyz https://lukesmith.xyz/videos Not Related! https://notrelated.xyz/ https://notrelated.xyz/rss 官大為 - Wiwi Kuan https://wiwikuan.com https://wiwikuan.com/index.xml Wiwi.Video 好和弦聯播網 https://wiwi.video https://wiwi.video/feeds/videos.atom?sort=-publishedAt 好檸檬 NiceLemon https://nicelemon.libsyn.com/ http://nicelemon.libsyn.com/rss ","date":"2021-04-28T22:21:40+08:00","permalink":"https://cld4h.github.io/blog/p/links-i-consoom/","title":"Links I \"consoom\""},{"content":"Reference1\nReference2-escaping shortcode in hugo\n创建 layouts/shortcodes/rawhtml.html 文件如下\n1 2 \u0026lt;!-- raw html --\u0026gt; {{.Inner}} 可以通过如下方式使用\n1 2 3 4 5 {{\u0026lt; rawhtml \u0026gt;}} \u0026lt;p class=\u0026#34;speshal-fancy-custom\u0026#34;\u0026gt; This is \u0026lt;strong\u0026gt;raw HTML\u0026lt;/strong\u0026gt;, inside Markdown. \u0026lt;/p\u0026gt; {{\u0026lt; /rawhtml \u0026gt;}} ","date":"2021-04-21T20:30:32+08:00","permalink":"https://cld4h.github.io/blog/p/raw-html-in-hugo/","title":"Raw HTML in Hugo"},{"content":"Update: Somehow I found it\u0026rsquo;s no longer needed in the stack theme.\nOfficial docs Reference\nI copied the default RSS template that ships with Hugo and changed line 28.\n1 2 3 4 28c28 \u0026lt; {{ range $pages }} --- \u0026gt; {{ range .Site.Pages }} I added the following line to my layouts/partials/menu-footer.html\n1 \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;{{.Site.BaseURL}}/index.xml\u0026#34;\u0026gt;\u0026lt;i class=\u0026#34;fas fa-rss\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; RSS\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; ","date":"2021-04-20T10:33:50+08:00","permalink":"https://cld4h.github.io/blog/p/rss-in-hugo/","title":"RSS in hugo"},{"content":"First install hugo on your system\nChoose a folder to run this command\n1 hugo new site blog cd into your site folder, init a git repo, and add a theme.\nIn my case I forked the learn theme in case I want to modify it.\nI then added the original branch as \u0026ldquo;learn\u0026rdquo; to track new updates.\n1 2 3 4 5 6 cd blog git init git submodule add git@github.com:cld4h/hugo-theme-learn.git themes/learn cd themes/learn git remote add -f learn https://github.com/matcornic/hugo-theme-learn.git git diff learn/master origin/master change the config.toml file\n1 2 3 4 5 6 # Change the default theme to be use when building the site with Hugo theme = \u0026#34;learn\u0026#34; # For search functionality [outputs] home = [ \u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] How this Chapter and this page is added\n1 2 hugo new --kind chapter hugo/_index.md hugo new hugo/start.md Start locally\n1 hugo serve -D Learn theme docs\n","date":"2021-03-24T12:18:03+08:00","permalink":"https://cld4h.github.io/blog/p/start-hugo/","title":"Start Hugo"},{"content":"Beamer 在Beamer中插入图片 (可参见Beamer文档12.6节)\nfigure 环境示例：\n1 2 3 4 5 6 \\begin{figure} \\centering \\includegraphics[width=\\textwidth]{pic/F1.png} \\caption{图中每个方块代表交易，右下角的数字表示交易本身的权重，粗体字表示累积权重。} \\label{fig:bef} \\end{figure} 为了使图片的caption有数字标号，在导言区加入下述内容：\n1 \\setbeamertemplate{caption}[numbered] 从markdown编译Beamer presentation 1 pandoc talk.md -t beamer -o talk.pdf --pdf-engine=xelatex -V mainfont=思源宋体 ","date":"2019-10-21T00:00:00Z","permalink":"https://cld4h.github.io/blog/p/latex-tips/","title":"LaTeX tips"},{"content":"题目来源\n2019 字节跳动 bytectf crypto lrlr\n参考\nTeam: W\u0026amp;M\nJarvis oj crypto\n先全文摘抄大佬的 Write Up 通过old的1000组可以预测python随机数， https://github.com/tna0y/Python-random-module-cracker\n一共2轮aes加密，既然密钥可以预测出来，自然就能解密得到clist。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes from Crypto.Cipher import AES import random from randcrack import RandCrack rc = RandCrack() with open(\u0026#39;old\u0026#39;) as file: old = [int(i) for i in file.read().strip().split(\u0026#39;\\n\u0026#39;)] index = 0 for i in range(index,624): rc.submit(old[index]) index+=1 for i in range(1000-624): assert(old[index]==rc.predict_getrandbits(32)) index+=1 with open(\u0026#39;cl\u0026#39;) as file: nlist = [eval(i) for i in file.read().strip().split(\u0026#39;\\n\u0026#39;)] with open(\u0026#39;new\u0026#39;) as file: clist=[i.decode(\u0026#39;hex\u0026#39;) for i in file.read().strip().split(\u0026#39;\\n\u0026#39;)] key1=[] key2=[] key3=[] for i in range(24): key1.append(rc.predict_getrandbits(128)) for i in range(24): key2.append(rc.predict_getrandbits(128)) for i in range(24): key3.append(rc.predict_getrandbits(128)) tmp1=[] for i in range(24): handle = AES.new(long_to_bytes(key3[i]), AES.MODE_CBC, \u0026#34;\\x00\u0026#34;*16) tmpstate=handle.decrypt(clist[i]) tmp1.append(tmpstate) tmp2=[] for i in range(24): handle = AES.new(long_to_bytes(key2[i]), AES.MODE_CBC, \u0026#34;\\x00\u0026#34;*16) tmpstate=handle.decrypt(tmp1[i]) tmp2.append(tmpstate) # tmp3=[] # for i in range(24): # handle = AES.new(long_to_bytes(key1[i]), AES.MODE_CBC, \u0026#34;\\x00\u0026#34;*16) # tmpstate=handle.decrypt(tmp2[i]) # tmp3.append(tmpstate) c=[] for i in tmp2: c.append(bytes_to_long(i)) for i in range(17): print \u0026#39;n = %d\u0026#39;%nlist[i] print \u0026#39;e = 17\u0026#39; print \u0026#39;c = %d\u0026#39;%c[i] print \u0026#39;\\n\u0026#39; 然后有了24组n,c；e=17。随便选择17组去广播攻击\n最后一步类似jarvis oj上的bbencode原题，循环编码，判断flag开头的字符串\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def bbencode(n): a = 0 for i in bin(n)[2:]: a = a \u0026lt;\u0026lt; 1 if (int(i)): a = a ^ n if a \u0026gt;\u0026gt; 256: a = a ^ 0x10000000000000000000000000000000000000000000000000000000000000223L return a result = 61406796444626535559771097418338494728649815464609781204026855332620301752444 for i in range(10000): result = bbencode(result) if(\u0026#34;666c6167\u0026#34; == str(hex(result))[2:10]): print i print hex(result)[2:-1].decode(\u0026#39;hex\u0026#39;) 下面写下细节 通过 oldtest() 中 random.getrandbits() 函数生成的随机数可以用 randcrack 库推断到之后 lrandout() 中调用 stateconvert() 和 gen_new_states() 时生成的128位随机数。\n此随机数直接作为AES-128加密的密钥对 clist[] 进行加密，IV值为128位0 。\n加密后的结果Append到 states[] 后，用的时候再通过 stateconvert 进行第二次AES加密(初始时(也就是 newtest 中第一个循环) states[] 数组中为长度为24的 clist[] 且 stateselse == 24 所以直接调用 stateconvert 一次加密得到输出)\n我们现在已知二次AES加密后的结果；已知 nlist[]；需要先由随机数生成规律推断出作为密钥的随机数，通过AES解密得到 clist[]；然后看 gen_states 函数发现 clist[] 中的元素是同一个消息(init_state) 以 $e=17$ 为指数模不同的 $n$ 值所得。此处可以进行低指数广播攻击。\n低指数广播攻击 参考 一叶飘零 的 Crypto-RSA-公钥攻击小结 参考 ashutosh1206 的 Hastad\u0026rsquo;s Broadcast Attack 所谓“低指数”，指的是指数 $e \u0026lt;= \\text{广播成员数量(加密的消息数量)}$\n中国剩余定理 对于下面的一元线性同余方程组：\n$$ \\begin{equation*} \\left\\lbrace \\begin{aligned} x \\equiv \u0026 a_1 \\bmod m_{1}\\\\ x \\equiv \u0026 a_2 \\bmod m_{2}\\\\ \u0026 \\vdots\\\\ x \\equiv \u0026 a_n \\bmod m_{n}\\\\ \\end{aligned} \\right. \\end{equation*} $$ 假设$m_1,m_2,\\ldots,m_n$中任意两数互质，则对任意整数$a_1,a_2,\\ldots,a_n$，上述方程组有解，通解的构造方法如下：\n设$M = m_1\\times m_2\\times \\cdots \\times m_{n} = \\prod\\limits_{i=1}^{n} m_{i} $ 是整数$m_1,m_2,\\ldots,m_{n}$ 的乘积 设$M_{i} = M / m_{i}, \\forall i \\in {1,2,\\ldots,n}$ 设$t_{i} = M_{i}^{-1}$ 为$M_{i}$ 模$m_{i}$ 的数论倒数 方程组的通解形式为： $$ x = a_1t_1M_1+a_2t_2M_2+\\cdots+a_{n}t_{n}M_{n} = kM+\\sum_{i=1}^{n} a_{i}t_{i}M_{i},\\qquad \\forall k \\in \\mathbb{Z}. $$ 在模$M$ 的意义下方程组只有一个解： $$ x=\\sum_{i=1}^{n} a_{i}t_{i}M_{i} $$ 因此，对于本题\n$$ \\begin{equation*} \\left\\lbrace \\begin{aligned} m^{17} \\equiv \u0026 c_1 \\bmod n_1\\\\ m^{17} \\equiv \u0026 c_2 \\bmod n_2\\\\ \u0026 \\vdots\\\\ m^{17} \\equiv \u0026 c_{17} \\bmod n_{17}\\\\ \\end{aligned} \\right. \\end{equation*} $$ (要求$n_1,n_2,\\ldots,n_{17}$两两互素，若不满足两两互素，可进行共模攻击)有\n$$ m^{17} = \\sum_{i=1}^{17} c_{i}N_{i}N_{i}^{-1} mod N $$\n其中，\n$ N = n_1\\times n_2\\times \\cdots \\times n_{17} = \\prod\\limits_{i=1}^{17} n_{i} $；\n$ N_{i} = N / n_{i} $；\n$ N_{i}^{-1} \\cdot N_{i} \\equiv 1 \\bmod n_{i} $\n因为$m \u0026lt; n_{i} \\quad \\forall i \\in {1,2,\\ldots,17}$，所以$ m^{17} \u0026lt; N = \\prod\\limits_{i=1}^{17} n_{i}$ 直接开方即可。\nhastad_unpadded.py 参考 只需关注 crt 函数和 hastad_unpadded 函数即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 #!/usr/bin/env python2.7 from Crypto.Util.number import GCD, bytes_to_long, long_to_bytes import gmpy2 def crt(list_a, list_m): \u0026#34;\u0026#34;\u0026#34; Reference: https://crypto.stanford.edu/pbc/notes/numbertheory/crt.html Returns the output after computing Chinese Remainder Theorem on x = a_1 mod m_1 x = a_2 mod m_2 ... x = a_n mod m_n input parameter list_a = [a_1, a_2, ..., a_n] input parameter list_m = [m_1, m_2, ..., m_n] Returns -1 if the operation is unsuccessful due to some exceptions \u0026#34;\u0026#34;\u0026#34; try: assert len(list_a) == len(list_m) except: print \u0026#34;[+] Length of list_a should be equal to length of list_m\u0026#34; return -1 for i in range(len(list_m)): for j in range(len(list_m)): if GCD(list_m[i], list_m[j])!= 1 and i!=j: print \u0026#34;[+] Moduli should be pairwise co-prime\u0026#34; return -1 M = 1 for i in list_m: M *= i list_b = [M/i for i in list_m] assert len(list_b) == len(list_m) try: list_b_inv = [int(gmpy2.invert(list_b[i], list_m[i])) for i in range(len(list_m))] except: print \u0026#34;[+] Encountered an unusual error while calculating inverse using gmpy2.invert()\u0026#34; return -1 x = 0 for i in range(len(list_m)): x += list_a[i]*list_b[i]*list_b_inv[i] return x % M def test_crt(): \u0026#34;\u0026#34;\u0026#34; Checking the validity and consistency of CRT function \u0026#34;\u0026#34;\u0026#34; list_a = [[2, 3], [1, 2, 3, 4], [6, 4]] list_m = [[5, 7], [5, 7, 9, 11], [7, 8]] soln_list = [17, 1731, 20] try: for i in range(len(list_a)): assert crt(list_a[i], list_m[i]) == soln_list[i] except: print \u0026#34;[+] CRT function broken. Check the function again!\u0026#34; def hastad_unpadded(ct_list, mod_list, e): \u0026#34;\u0026#34;\u0026#34; Implementing Hastad\u0026#39;s Broadcast Attack \u0026#34;\u0026#34;\u0026#34; m_expo = crt(ct_list, mod_list) if m_expo != -1: eth_root = gmpy2.iroot(m_expo, e) if eth_root[1] == False: print \u0026#34;[+] Cannot calculate e\u0026#39;th root!\u0026#34; return -1 elif eth_root[1] == True: # 注意，eth_root 为元组(mpz对象,布尔值)，需用eth_root[0]提取mpz对象 # 也可用gmpy2.digits(eth_root[0]) # 以字符串形式返回正确的结果 # https://gmpy2.readthedocs.io/en/latest/mpz.html#mpz-functions return long_to_bytes(eth_root[0]) else: print \u0026#34;[+] Cannot calculate CRT\u0026#34; return -1 test_crt() 对于此题，我们传入 hastad_unpadded(ct_list, mod_list, e) 函数的三个参数分别为\nct_list = clist mod_list = nlist e = 17 (clist 和 nlist 通过前面大佬给的WP中的代码即可得到，用到了 randcrack 库)\n通过上述代码我们成功得到了 init_state 的值\n与前面大佬给的一致.\nbbencode 获得 init_state 后就与 Jarvis OJ 上的题目完全一致了 主要参考 Jarvis oj crypto\n大致的意思是将 bbencode 的输出再传给 bbencode ，反复作用，每一次都查看一下结果中前四个字节是不是“flag” ，如下：\n1 if(\u0026#34;666c6167\u0026#34; == str(hex(result))[2:10]): \u0026ldquo;666c6167\u0026rdquo; 正好是 flag 的ascii码\n由于for循环执行10000次，每2695次迭代会得到一次flag，所以会输出三次flag\n","date":"2019-09-17T19:11:45+08:00","permalink":"https://cld4h.github.io/blog/p/lrlr/","title":"lrlr"}]